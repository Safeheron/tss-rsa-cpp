// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tss_rsa.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tss_5frsa_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tss_5frsa_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tss_5frsa_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tss_5frsa_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tss_5frsa_2eproto;
namespace safeheron {
namespace proto {
class RSAKeyMeta;
struct RSAKeyMetaDefaultTypeInternal;
extern RSAKeyMetaDefaultTypeInternal _RSAKeyMeta_default_instance_;
class RSAPrivateKeyShare;
struct RSAPrivateKeyShareDefaultTypeInternal;
extern RSAPrivateKeyShareDefaultTypeInternal _RSAPrivateKeyShare_default_instance_;
class RSAPublicKey;
struct RSAPublicKeyDefaultTypeInternal;
extern RSAPublicKeyDefaultTypeInternal _RSAPublicKey_default_instance_;
class RSASigShare;
struct RSASigShareDefaultTypeInternal;
extern RSASigShareDefaultTypeInternal _RSASigShare_default_instance_;
class RSASigShareProof;
struct RSASigShareProofDefaultTypeInternal;
extern RSASigShareProofDefaultTypeInternal _RSASigShareProof_default_instance_;
}  // namespace proto
}  // namespace safeheron
PROTOBUF_NAMESPACE_OPEN
template<> ::safeheron::proto::RSAKeyMeta* Arena::CreateMaybeMessage<::safeheron::proto::RSAKeyMeta>(Arena*);
template<> ::safeheron::proto::RSAPrivateKeyShare* Arena::CreateMaybeMessage<::safeheron::proto::RSAPrivateKeyShare>(Arena*);
template<> ::safeheron::proto::RSAPublicKey* Arena::CreateMaybeMessage<::safeheron::proto::RSAPublicKey>(Arena*);
template<> ::safeheron::proto::RSASigShare* Arena::CreateMaybeMessage<::safeheron::proto::RSASigShare>(Arena*);
template<> ::safeheron::proto::RSASigShareProof* Arena::CreateMaybeMessage<::safeheron::proto::RSASigShareProof>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace safeheron {
namespace proto {

// ===================================================================

class RSAPublicKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSAPublicKey) */ {
 public:
  inline RSAPublicKey() : RSAPublicKey(nullptr) {}
  ~RSAPublicKey() override;
  explicit PROTOBUF_CONSTEXPR RSAPublicKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RSAPublicKey(const RSAPublicKey& from);
  RSAPublicKey(RSAPublicKey&& from) noexcept
    : RSAPublicKey() {
    *this = ::std::move(from);
  }

  inline RSAPublicKey& operator=(const RSAPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSAPublicKey& operator=(RSAPublicKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RSAPublicKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const RSAPublicKey* internal_default_instance() {
    return reinterpret_cast<const RSAPublicKey*>(
               &_RSAPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RSAPublicKey& a, RSAPublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(RSAPublicKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSAPublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RSAPublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RSAPublicKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RSAPublicKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RSAPublicKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSAPublicKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RSAPublicKey";
  }
  protected:
  explicit RSAPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNFieldNumber = 1,
    kEFieldNumber = 2,
  };
  // string n = 1;
  void clear_n();
  const std::string& n() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_n(ArgT0&& arg0, ArgT... args);
  std::string* mutable_n();
  PROTOBUF_NODISCARD std::string* release_n();
  void set_allocated_n(std::string* n);
  private:
  const std::string& _internal_n() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_n(const std::string& value);
  std::string* _internal_mutable_n();
  public:

  // string e = 2;
  void clear_e();
  const std::string& e() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e();
  PROTOBUF_NODISCARD std::string* release_e();
  void set_allocated_e(std::string* e);
  private:
  const std::string& _internal_e() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e(const std::string& value);
  std::string* _internal_mutable_e();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSAPublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr n_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSAPrivateKeyShare final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSAPrivateKeyShare) */ {
 public:
  inline RSAPrivateKeyShare() : RSAPrivateKeyShare(nullptr) {}
  ~RSAPrivateKeyShare() override;
  explicit PROTOBUF_CONSTEXPR RSAPrivateKeyShare(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RSAPrivateKeyShare(const RSAPrivateKeyShare& from);
  RSAPrivateKeyShare(RSAPrivateKeyShare&& from) noexcept
    : RSAPrivateKeyShare() {
    *this = ::std::move(from);
  }

  inline RSAPrivateKeyShare& operator=(const RSAPrivateKeyShare& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSAPrivateKeyShare& operator=(RSAPrivateKeyShare&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RSAPrivateKeyShare& default_instance() {
    return *internal_default_instance();
  }
  static inline const RSAPrivateKeyShare* internal_default_instance() {
    return reinterpret_cast<const RSAPrivateKeyShare*>(
               &_RSAPrivateKeyShare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RSAPrivateKeyShare& a, RSAPrivateKeyShare& b) {
    a.Swap(&b);
  }
  inline void Swap(RSAPrivateKeyShare* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSAPrivateKeyShare* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RSAPrivateKeyShare* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RSAPrivateKeyShare>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RSAPrivateKeyShare& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RSAPrivateKeyShare& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSAPrivateKeyShare* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RSAPrivateKeyShare";
  }
  protected:
  explicit RSAPrivateKeyShare(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSiFieldNumber = 2,
    kIFieldNumber = 1,
  };
  // string si = 2;
  void clear_si();
  const std::string& si() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_si(ArgT0&& arg0, ArgT... args);
  std::string* mutable_si();
  PROTOBUF_NODISCARD std::string* release_si();
  void set_allocated_si(std::string* si);
  private:
  const std::string& _internal_si() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_si(const std::string& value);
  std::string* _internal_mutable_si();
  public:

  // int32 i = 1;
  void clear_i();
  int32_t i() const;
  void set_i(int32_t value);
  private:
  int32_t _internal_i() const;
  void _internal_set_i(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSAPrivateKeyShare)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr si_;
  int32_t i_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSAKeyMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSAKeyMeta) */ {
 public:
  inline RSAKeyMeta() : RSAKeyMeta(nullptr) {}
  ~RSAKeyMeta() override;
  explicit PROTOBUF_CONSTEXPR RSAKeyMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RSAKeyMeta(const RSAKeyMeta& from);
  RSAKeyMeta(RSAKeyMeta&& from) noexcept
    : RSAKeyMeta() {
    *this = ::std::move(from);
  }

  inline RSAKeyMeta& operator=(const RSAKeyMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSAKeyMeta& operator=(RSAKeyMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RSAKeyMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const RSAKeyMeta* internal_default_instance() {
    return reinterpret_cast<const RSAKeyMeta*>(
               &_RSAKeyMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RSAKeyMeta& a, RSAKeyMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(RSAKeyMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSAKeyMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RSAKeyMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RSAKeyMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RSAKeyMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RSAKeyMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSAKeyMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RSAKeyMeta";
  }
  protected:
  explicit RSAKeyMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVkiArrFieldNumber = 5,
    kVkvFieldNumber = 3,
    kVkuFieldNumber = 4,
    kKFieldNumber = 1,
    kLFieldNumber = 2,
  };
  // repeated string vki_arr = 5;
  int vki_arr_size() const;
  private:
  int _internal_vki_arr_size() const;
  public:
  void clear_vki_arr();
  const std::string& vki_arr(int index) const;
  std::string* mutable_vki_arr(int index);
  void set_vki_arr(int index, const std::string& value);
  void set_vki_arr(int index, std::string&& value);
  void set_vki_arr(int index, const char* value);
  void set_vki_arr(int index, const char* value, size_t size);
  std::string* add_vki_arr();
  void add_vki_arr(const std::string& value);
  void add_vki_arr(std::string&& value);
  void add_vki_arr(const char* value);
  void add_vki_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vki_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vki_arr();
  private:
  const std::string& _internal_vki_arr(int index) const;
  std::string* _internal_add_vki_arr();
  public:

  // string vkv = 3;
  void clear_vkv();
  const std::string& vkv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vkv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vkv();
  PROTOBUF_NODISCARD std::string* release_vkv();
  void set_allocated_vkv(std::string* vkv);
  private:
  const std::string& _internal_vkv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vkv(const std::string& value);
  std::string* _internal_mutable_vkv();
  public:

  // string vku = 4;
  void clear_vku();
  const std::string& vku() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vku(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vku();
  PROTOBUF_NODISCARD std::string* release_vku();
  void set_allocated_vku(std::string* vku);
  private:
  const std::string& _internal_vku() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vku(const std::string& value);
  std::string* _internal_mutable_vku();
  public:

  // int32 k = 1;
  void clear_k();
  int32_t k() const;
  void set_k(int32_t value);
  private:
  int32_t _internal_k() const;
  void _internal_set_k(int32_t value);
  public:

  // int32 l = 2;
  void clear_l();
  int32_t l() const;
  void set_l(int32_t value);
  private:
  int32_t _internal_l() const;
  void _internal_set_l(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSAKeyMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vki_arr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vkv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vku_;
  int32_t k_;
  int32_t l_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSASigShare final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSASigShare) */ {
 public:
  inline RSASigShare() : RSASigShare(nullptr) {}
  ~RSASigShare() override;
  explicit PROTOBUF_CONSTEXPR RSASigShare(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RSASigShare(const RSASigShare& from);
  RSASigShare(RSASigShare&& from) noexcept
    : RSASigShare() {
    *this = ::std::move(from);
  }

  inline RSASigShare& operator=(const RSASigShare& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSASigShare& operator=(RSASigShare&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RSASigShare& default_instance() {
    return *internal_default_instance();
  }
  static inline const RSASigShare* internal_default_instance() {
    return reinterpret_cast<const RSASigShare*>(
               &_RSASigShare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RSASigShare& a, RSASigShare& b) {
    a.Swap(&b);
  }
  inline void Swap(RSASigShare* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSASigShare* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RSASigShare* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RSASigShare>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RSASigShare& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RSASigShare& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSASigShare* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RSASigShare";
  }
  protected:
  explicit RSASigShare(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigShareFieldNumber = 2,
    kZFieldNumber = 3,
    kCFieldNumber = 4,
    kIndexFieldNumber = 1,
  };
  // string sig_share = 2;
  void clear_sig_share();
  const std::string& sig_share() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sig_share(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sig_share();
  PROTOBUF_NODISCARD std::string* release_sig_share();
  void set_allocated_sig_share(std::string* sig_share);
  private:
  const std::string& _internal_sig_share() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sig_share(const std::string& value);
  std::string* _internal_mutable_sig_share();
  public:

  // string z = 3;
  void clear_z();
  const std::string& z() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string c = 4;
  void clear_c();
  const std::string& c() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_c(ArgT0&& arg0, ArgT... args);
  std::string* mutable_c();
  PROTOBUF_NODISCARD std::string* release_c();
  void set_allocated_c(std::string* c);
  private:
  const std::string& _internal_c() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_c(const std::string& value);
  std::string* _internal_mutable_c();
  public:

  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSASigShare)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_share_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr c_;
  int32_t index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSASigShareProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSASigShareProof) */ {
 public:
  inline RSASigShareProof() : RSASigShareProof(nullptr) {}
  ~RSASigShareProof() override;
  explicit PROTOBUF_CONSTEXPR RSASigShareProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RSASigShareProof(const RSASigShareProof& from);
  RSASigShareProof(RSASigShareProof&& from) noexcept
    : RSASigShareProof() {
    *this = ::std::move(from);
  }

  inline RSASigShareProof& operator=(const RSASigShareProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSASigShareProof& operator=(RSASigShareProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RSASigShareProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const RSASigShareProof* internal_default_instance() {
    return reinterpret_cast<const RSASigShareProof*>(
               &_RSASigShareProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RSASigShareProof& a, RSASigShareProof& b) {
    a.Swap(&b);
  }
  inline void Swap(RSASigShareProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSASigShareProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RSASigShareProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RSASigShareProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RSASigShareProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RSASigShareProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSASigShareProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RSASigShareProof";
  }
  protected:
  explicit RSASigShareProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZFieldNumber = 1,
    kCFieldNumber = 2,
  };
  // string z = 1;
  void clear_z();
  const std::string& z() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string c = 2;
  void clear_c();
  const std::string& c() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_c(ArgT0&& arg0, ArgT... args);
  std::string* mutable_c();
  PROTOBUF_NODISCARD std::string* release_c();
  void set_allocated_c(std::string* c);
  private:
  const std::string& _internal_c() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_c(const std::string& value);
  std::string* _internal_mutable_c();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSASigShareProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr c_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RSAPublicKey

// string n = 1;
inline void RSAPublicKey::clear_n() {
  n_.ClearToEmpty();
}
inline const std::string& RSAPublicKey::n() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPublicKey.n)
  return _internal_n();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RSAPublicKey::set_n(ArgT0&& arg0, ArgT... args) {
 
 n_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPublicKey.n)
}
inline std::string* RSAPublicKey::mutable_n() {
  std::string* _s = _internal_mutable_n();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAPublicKey.n)
  return _s;
}
inline const std::string& RSAPublicKey::_internal_n() const {
  return n_.Get();
}
inline void RSAPublicKey::_internal_set_n(const std::string& value) {
  
  n_.Set(value, GetArenaForAllocation());
}
inline std::string* RSAPublicKey::_internal_mutable_n() {
  
  return n_.Mutable(GetArenaForAllocation());
}
inline std::string* RSAPublicKey::release_n() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAPublicKey.n)
  return n_.Release();
}
inline void RSAPublicKey::set_allocated_n(std::string* n) {
  if (n != nullptr) {
    
  } else {
    
  }
  n_.SetAllocated(n, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (n_.IsDefault()) {
    n_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAPublicKey.n)
}

// string e = 2;
inline void RSAPublicKey::clear_e() {
  e_.ClearToEmpty();
}
inline const std::string& RSAPublicKey::e() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPublicKey.e)
  return _internal_e();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RSAPublicKey::set_e(ArgT0&& arg0, ArgT... args) {
 
 e_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPublicKey.e)
}
inline std::string* RSAPublicKey::mutable_e() {
  std::string* _s = _internal_mutable_e();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAPublicKey.e)
  return _s;
}
inline const std::string& RSAPublicKey::_internal_e() const {
  return e_.Get();
}
inline void RSAPublicKey::_internal_set_e(const std::string& value) {
  
  e_.Set(value, GetArenaForAllocation());
}
inline std::string* RSAPublicKey::_internal_mutable_e() {
  
  return e_.Mutable(GetArenaForAllocation());
}
inline std::string* RSAPublicKey::release_e() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAPublicKey.e)
  return e_.Release();
}
inline void RSAPublicKey::set_allocated_e(std::string* e) {
  if (e != nullptr) {
    
  } else {
    
  }
  e_.SetAllocated(e, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e_.IsDefault()) {
    e_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAPublicKey.e)
}

// -------------------------------------------------------------------

// RSAPrivateKeyShare

// int32 i = 1;
inline void RSAPrivateKeyShare::clear_i() {
  i_ = 0;
}
inline int32_t RSAPrivateKeyShare::_internal_i() const {
  return i_;
}
inline int32_t RSAPrivateKeyShare::i() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPrivateKeyShare.i)
  return _internal_i();
}
inline void RSAPrivateKeyShare::_internal_set_i(int32_t value) {
  
  i_ = value;
}
inline void RSAPrivateKeyShare::set_i(int32_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPrivateKeyShare.i)
}

// string si = 2;
inline void RSAPrivateKeyShare::clear_si() {
  si_.ClearToEmpty();
}
inline const std::string& RSAPrivateKeyShare::si() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPrivateKeyShare.si)
  return _internal_si();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RSAPrivateKeyShare::set_si(ArgT0&& arg0, ArgT... args) {
 
 si_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPrivateKeyShare.si)
}
inline std::string* RSAPrivateKeyShare::mutable_si() {
  std::string* _s = _internal_mutable_si();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAPrivateKeyShare.si)
  return _s;
}
inline const std::string& RSAPrivateKeyShare::_internal_si() const {
  return si_.Get();
}
inline void RSAPrivateKeyShare::_internal_set_si(const std::string& value) {
  
  si_.Set(value, GetArenaForAllocation());
}
inline std::string* RSAPrivateKeyShare::_internal_mutable_si() {
  
  return si_.Mutable(GetArenaForAllocation());
}
inline std::string* RSAPrivateKeyShare::release_si() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAPrivateKeyShare.si)
  return si_.Release();
}
inline void RSAPrivateKeyShare::set_allocated_si(std::string* si) {
  if (si != nullptr) {
    
  } else {
    
  }
  si_.SetAllocated(si, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (si_.IsDefault()) {
    si_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAPrivateKeyShare.si)
}

// -------------------------------------------------------------------

// RSAKeyMeta

// int32 k = 1;
inline void RSAKeyMeta::clear_k() {
  k_ = 0;
}
inline int32_t RSAKeyMeta::_internal_k() const {
  return k_;
}
inline int32_t RSAKeyMeta::k() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.k)
  return _internal_k();
}
inline void RSAKeyMeta::_internal_set_k(int32_t value) {
  
  k_ = value;
}
inline void RSAKeyMeta::set_k(int32_t value) {
  _internal_set_k(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.k)
}

// int32 l = 2;
inline void RSAKeyMeta::clear_l() {
  l_ = 0;
}
inline int32_t RSAKeyMeta::_internal_l() const {
  return l_;
}
inline int32_t RSAKeyMeta::l() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.l)
  return _internal_l();
}
inline void RSAKeyMeta::_internal_set_l(int32_t value) {
  
  l_ = value;
}
inline void RSAKeyMeta::set_l(int32_t value) {
  _internal_set_l(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.l)
}

// string vkv = 3;
inline void RSAKeyMeta::clear_vkv() {
  vkv_.ClearToEmpty();
}
inline const std::string& RSAKeyMeta::vkv() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.vkv)
  return _internal_vkv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RSAKeyMeta::set_vkv(ArgT0&& arg0, ArgT... args) {
 
 vkv_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vkv)
}
inline std::string* RSAKeyMeta::mutable_vkv() {
  std::string* _s = _internal_mutable_vkv();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAKeyMeta.vkv)
  return _s;
}
inline const std::string& RSAKeyMeta::_internal_vkv() const {
  return vkv_.Get();
}
inline void RSAKeyMeta::_internal_set_vkv(const std::string& value) {
  
  vkv_.Set(value, GetArenaForAllocation());
}
inline std::string* RSAKeyMeta::_internal_mutable_vkv() {
  
  return vkv_.Mutable(GetArenaForAllocation());
}
inline std::string* RSAKeyMeta::release_vkv() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAKeyMeta.vkv)
  return vkv_.Release();
}
inline void RSAKeyMeta::set_allocated_vkv(std::string* vkv) {
  if (vkv != nullptr) {
    
  } else {
    
  }
  vkv_.SetAllocated(vkv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vkv_.IsDefault()) {
    vkv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAKeyMeta.vkv)
}

// string vku = 4;
inline void RSAKeyMeta::clear_vku() {
  vku_.ClearToEmpty();
}
inline const std::string& RSAKeyMeta::vku() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.vku)
  return _internal_vku();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RSAKeyMeta::set_vku(ArgT0&& arg0, ArgT... args) {
 
 vku_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vku)
}
inline std::string* RSAKeyMeta::mutable_vku() {
  std::string* _s = _internal_mutable_vku();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAKeyMeta.vku)
  return _s;
}
inline const std::string& RSAKeyMeta::_internal_vku() const {
  return vku_.Get();
}
inline void RSAKeyMeta::_internal_set_vku(const std::string& value) {
  
  vku_.Set(value, GetArenaForAllocation());
}
inline std::string* RSAKeyMeta::_internal_mutable_vku() {
  
  return vku_.Mutable(GetArenaForAllocation());
}
inline std::string* RSAKeyMeta::release_vku() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAKeyMeta.vku)
  return vku_.Release();
}
inline void RSAKeyMeta::set_allocated_vku(std::string* vku) {
  if (vku != nullptr) {
    
  } else {
    
  }
  vku_.SetAllocated(vku, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vku_.IsDefault()) {
    vku_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAKeyMeta.vku)
}

// repeated string vki_arr = 5;
inline int RSAKeyMeta::_internal_vki_arr_size() const {
  return vki_arr_.size();
}
inline int RSAKeyMeta::vki_arr_size() const {
  return _internal_vki_arr_size();
}
inline void RSAKeyMeta::clear_vki_arr() {
  vki_arr_.Clear();
}
inline std::string* RSAKeyMeta::add_vki_arr() {
  std::string* _s = _internal_add_vki_arr();
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.RSAKeyMeta.vki_arr)
  return _s;
}
inline const std::string& RSAKeyMeta::_internal_vki_arr(int index) const {
  return vki_arr_.Get(index);
}
inline const std::string& RSAKeyMeta::vki_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.vki_arr)
  return _internal_vki_arr(index);
}
inline std::string* RSAKeyMeta::mutable_vki_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAKeyMeta.vki_arr)
  return vki_arr_.Mutable(index);
}
inline void RSAKeyMeta::set_vki_arr(int index, const std::string& value) {
  vki_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::set_vki_arr(int index, std::string&& value) {
  vki_arr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::set_vki_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vki_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::set_vki_arr(int index, const char* value, size_t size) {
  vki_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline std::string* RSAKeyMeta::_internal_add_vki_arr() {
  return vki_arr_.Add();
}
inline void RSAKeyMeta::add_vki_arr(const std::string& value) {
  vki_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::add_vki_arr(std::string&& value) {
  vki_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::add_vki_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vki_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::add_vki_arr(const char* value, size_t size) {
  vki_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RSAKeyMeta::vki_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.RSAKeyMeta.vki_arr)
  return vki_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RSAKeyMeta::mutable_vki_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.RSAKeyMeta.vki_arr)
  return &vki_arr_;
}

// -------------------------------------------------------------------

// RSASigShare

// int32 index = 1;
inline void RSASigShare::clear_index() {
  index_ = 0;
}
inline int32_t RSASigShare::_internal_index() const {
  return index_;
}
inline int32_t RSASigShare::index() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.index)
  return _internal_index();
}
inline void RSASigShare::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void RSASigShare::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.index)
}

// string sig_share = 2;
inline void RSASigShare::clear_sig_share() {
  sig_share_.ClearToEmpty();
}
inline const std::string& RSASigShare::sig_share() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.sig_share)
  return _internal_sig_share();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RSASigShare::set_sig_share(ArgT0&& arg0, ArgT... args) {
 
 sig_share_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.sig_share)
}
inline std::string* RSASigShare::mutable_sig_share() {
  std::string* _s = _internal_mutable_sig_share();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShare.sig_share)
  return _s;
}
inline const std::string& RSASigShare::_internal_sig_share() const {
  return sig_share_.Get();
}
inline void RSASigShare::_internal_set_sig_share(const std::string& value) {
  
  sig_share_.Set(value, GetArenaForAllocation());
}
inline std::string* RSASigShare::_internal_mutable_sig_share() {
  
  return sig_share_.Mutable(GetArenaForAllocation());
}
inline std::string* RSASigShare::release_sig_share() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShare.sig_share)
  return sig_share_.Release();
}
inline void RSASigShare::set_allocated_sig_share(std::string* sig_share) {
  if (sig_share != nullptr) {
    
  } else {
    
  }
  sig_share_.SetAllocated(sig_share, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sig_share_.IsDefault()) {
    sig_share_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShare.sig_share)
}

// string z = 3;
inline void RSASigShare::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& RSASigShare::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.z)
  return _internal_z();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RSASigShare::set_z(ArgT0&& arg0, ArgT... args) {
 
 z_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.z)
}
inline std::string* RSASigShare::mutable_z() {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShare.z)
  return _s;
}
inline const std::string& RSASigShare::_internal_z() const {
  return z_.Get();
}
inline void RSASigShare::_internal_set_z(const std::string& value) {
  
  z_.Set(value, GetArenaForAllocation());
}
inline std::string* RSASigShare::_internal_mutable_z() {
  
  return z_.Mutable(GetArenaForAllocation());
}
inline std::string* RSASigShare::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShare.z)
  return z_.Release();
}
inline void RSASigShare::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(z, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_.IsDefault()) {
    z_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShare.z)
}

// string c = 4;
inline void RSASigShare::clear_c() {
  c_.ClearToEmpty();
}
inline const std::string& RSASigShare::c() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.c)
  return _internal_c();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RSASigShare::set_c(ArgT0&& arg0, ArgT... args) {
 
 c_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.c)
}
inline std::string* RSASigShare::mutable_c() {
  std::string* _s = _internal_mutable_c();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShare.c)
  return _s;
}
inline const std::string& RSASigShare::_internal_c() const {
  return c_.Get();
}
inline void RSASigShare::_internal_set_c(const std::string& value) {
  
  c_.Set(value, GetArenaForAllocation());
}
inline std::string* RSASigShare::_internal_mutable_c() {
  
  return c_.Mutable(GetArenaForAllocation());
}
inline std::string* RSASigShare::release_c() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShare.c)
  return c_.Release();
}
inline void RSASigShare::set_allocated_c(std::string* c) {
  if (c != nullptr) {
    
  } else {
    
  }
  c_.SetAllocated(c, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (c_.IsDefault()) {
    c_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShare.c)
}

// -------------------------------------------------------------------

// RSASigShareProof

// string z = 1;
inline void RSASigShareProof::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& RSASigShareProof::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShareProof.z)
  return _internal_z();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RSASigShareProof::set_z(ArgT0&& arg0, ArgT... args) {
 
 z_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShareProof.z)
}
inline std::string* RSASigShareProof::mutable_z() {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShareProof.z)
  return _s;
}
inline const std::string& RSASigShareProof::_internal_z() const {
  return z_.Get();
}
inline void RSASigShareProof::_internal_set_z(const std::string& value) {
  
  z_.Set(value, GetArenaForAllocation());
}
inline std::string* RSASigShareProof::_internal_mutable_z() {
  
  return z_.Mutable(GetArenaForAllocation());
}
inline std::string* RSASigShareProof::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShareProof.z)
  return z_.Release();
}
inline void RSASigShareProof::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(z, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_.IsDefault()) {
    z_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShareProof.z)
}

// string c = 2;
inline void RSASigShareProof::clear_c() {
  c_.ClearToEmpty();
}
inline const std::string& RSASigShareProof::c() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShareProof.c)
  return _internal_c();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RSASigShareProof::set_c(ArgT0&& arg0, ArgT... args) {
 
 c_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShareProof.c)
}
inline std::string* RSASigShareProof::mutable_c() {
  std::string* _s = _internal_mutable_c();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShareProof.c)
  return _s;
}
inline const std::string& RSASigShareProof::_internal_c() const {
  return c_.Get();
}
inline void RSASigShareProof::_internal_set_c(const std::string& value) {
  
  c_.Set(value, GetArenaForAllocation());
}
inline std::string* RSASigShareProof::_internal_mutable_c() {
  
  return c_.Mutable(GetArenaForAllocation());
}
inline std::string* RSASigShareProof::release_c() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShareProof.c)
  return c_.Release();
}
inline void RSASigShareProof::set_allocated_c(std::string* c) {
  if (c != nullptr) {
    
  } else {
    
  }
  c_.SetAllocated(c, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (c_.IsDefault()) {
    c_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShareProof.c)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace safeheron

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tss_5frsa_2eproto
