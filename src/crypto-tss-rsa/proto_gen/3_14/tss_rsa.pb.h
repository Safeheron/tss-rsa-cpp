// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tss_rsa.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tss_5frsa_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tss_5frsa_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tss_5frsa_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tss_5frsa_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tss_5frsa_2eproto;
namespace safeheron {
namespace proto {
class RSAKeyMeta;
class RSAKeyMetaDefaultTypeInternal;
extern RSAKeyMetaDefaultTypeInternal _RSAKeyMeta_default_instance_;
class RSAPrivateKeyShare;
class RSAPrivateKeyShareDefaultTypeInternal;
extern RSAPrivateKeyShareDefaultTypeInternal _RSAPrivateKeyShare_default_instance_;
class RSAPublicKey;
class RSAPublicKeyDefaultTypeInternal;
extern RSAPublicKeyDefaultTypeInternal _RSAPublicKey_default_instance_;
class RSASigShare;
class RSASigShareDefaultTypeInternal;
extern RSASigShareDefaultTypeInternal _RSASigShare_default_instance_;
class RSASigShareProof;
class RSASigShareProofDefaultTypeInternal;
extern RSASigShareProofDefaultTypeInternal _RSASigShareProof_default_instance_;
}  // namespace proto
}  // namespace safeheron
PROTOBUF_NAMESPACE_OPEN
template<> ::safeheron::proto::RSAKeyMeta* Arena::CreateMaybeMessage<::safeheron::proto::RSAKeyMeta>(Arena*);
template<> ::safeheron::proto::RSAPrivateKeyShare* Arena::CreateMaybeMessage<::safeheron::proto::RSAPrivateKeyShare>(Arena*);
template<> ::safeheron::proto::RSAPublicKey* Arena::CreateMaybeMessage<::safeheron::proto::RSAPublicKey>(Arena*);
template<> ::safeheron::proto::RSASigShare* Arena::CreateMaybeMessage<::safeheron::proto::RSASigShare>(Arena*);
template<> ::safeheron::proto::RSASigShareProof* Arena::CreateMaybeMessage<::safeheron::proto::RSASigShareProof>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace safeheron {
namespace proto {

// ===================================================================

class RSAPublicKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSAPublicKey) */ {
 public:
  inline RSAPublicKey() : RSAPublicKey(nullptr) {}
  virtual ~RSAPublicKey();

  RSAPublicKey(const RSAPublicKey& from);
  RSAPublicKey(RSAPublicKey&& from) noexcept
    : RSAPublicKey() {
    *this = ::std::move(from);
  }

  inline RSAPublicKey& operator=(const RSAPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSAPublicKey& operator=(RSAPublicKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RSAPublicKey& default_instance();

  static inline const RSAPublicKey* internal_default_instance() {
    return reinterpret_cast<const RSAPublicKey*>(
               &_RSAPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RSAPublicKey& a, RSAPublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(RSAPublicKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSAPublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RSAPublicKey* New() const final {
    return CreateMaybeMessage<RSAPublicKey>(nullptr);
  }

  RSAPublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RSAPublicKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RSAPublicKey& from);
  void MergeFrom(const RSAPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSAPublicKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RSAPublicKey";
  }
  protected:
  explicit RSAPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tss_5frsa_2eproto);
    return ::descriptor_table_tss_5frsa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNFieldNumber = 1,
    kEFieldNumber = 2,
  };
  // string n = 1;
  void clear_n();
  const std::string& n() const;
  void set_n(const std::string& value);
  void set_n(std::string&& value);
  void set_n(const char* value);
  void set_n(const char* value, size_t size);
  std::string* mutable_n();
  std::string* release_n();
  void set_allocated_n(std::string* n);
  private:
  const std::string& _internal_n() const;
  void _internal_set_n(const std::string& value);
  std::string* _internal_mutable_n();
  public:

  // string e = 2;
  void clear_e();
  const std::string& e() const;
  void set_e(const std::string& value);
  void set_e(std::string&& value);
  void set_e(const char* value);
  void set_e(const char* value, size_t size);
  std::string* mutable_e();
  std::string* release_e();
  void set_allocated_e(std::string* e);
  private:
  const std::string& _internal_e() const;
  void _internal_set_e(const std::string& value);
  std::string* _internal_mutable_e();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSAPublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr n_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSAPrivateKeyShare PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSAPrivateKeyShare) */ {
 public:
  inline RSAPrivateKeyShare() : RSAPrivateKeyShare(nullptr) {}
  virtual ~RSAPrivateKeyShare();

  RSAPrivateKeyShare(const RSAPrivateKeyShare& from);
  RSAPrivateKeyShare(RSAPrivateKeyShare&& from) noexcept
    : RSAPrivateKeyShare() {
    *this = ::std::move(from);
  }

  inline RSAPrivateKeyShare& operator=(const RSAPrivateKeyShare& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSAPrivateKeyShare& operator=(RSAPrivateKeyShare&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RSAPrivateKeyShare& default_instance();

  static inline const RSAPrivateKeyShare* internal_default_instance() {
    return reinterpret_cast<const RSAPrivateKeyShare*>(
               &_RSAPrivateKeyShare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RSAPrivateKeyShare& a, RSAPrivateKeyShare& b) {
    a.Swap(&b);
  }
  inline void Swap(RSAPrivateKeyShare* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSAPrivateKeyShare* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RSAPrivateKeyShare* New() const final {
    return CreateMaybeMessage<RSAPrivateKeyShare>(nullptr);
  }

  RSAPrivateKeyShare* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RSAPrivateKeyShare>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RSAPrivateKeyShare& from);
  void MergeFrom(const RSAPrivateKeyShare& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSAPrivateKeyShare* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RSAPrivateKeyShare";
  }
  protected:
  explicit RSAPrivateKeyShare(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tss_5frsa_2eproto);
    return ::descriptor_table_tss_5frsa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSiFieldNumber = 2,
    kIFieldNumber = 1,
  };
  // string si = 2;
  void clear_si();
  const std::string& si() const;
  void set_si(const std::string& value);
  void set_si(std::string&& value);
  void set_si(const char* value);
  void set_si(const char* value, size_t size);
  std::string* mutable_si();
  std::string* release_si();
  void set_allocated_si(std::string* si);
  private:
  const std::string& _internal_si() const;
  void _internal_set_si(const std::string& value);
  std::string* _internal_mutable_si();
  public:

  // int32 i = 1;
  void clear_i();
  ::PROTOBUF_NAMESPACE_ID::int32 i() const;
  void set_i(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_i() const;
  void _internal_set_i(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSAPrivateKeyShare)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr si_;
  ::PROTOBUF_NAMESPACE_ID::int32 i_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSAKeyMeta PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSAKeyMeta) */ {
 public:
  inline RSAKeyMeta() : RSAKeyMeta(nullptr) {}
  virtual ~RSAKeyMeta();

  RSAKeyMeta(const RSAKeyMeta& from);
  RSAKeyMeta(RSAKeyMeta&& from) noexcept
    : RSAKeyMeta() {
    *this = ::std::move(from);
  }

  inline RSAKeyMeta& operator=(const RSAKeyMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSAKeyMeta& operator=(RSAKeyMeta&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RSAKeyMeta& default_instance();

  static inline const RSAKeyMeta* internal_default_instance() {
    return reinterpret_cast<const RSAKeyMeta*>(
               &_RSAKeyMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RSAKeyMeta& a, RSAKeyMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(RSAKeyMeta* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSAKeyMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RSAKeyMeta* New() const final {
    return CreateMaybeMessage<RSAKeyMeta>(nullptr);
  }

  RSAKeyMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RSAKeyMeta>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RSAKeyMeta& from);
  void MergeFrom(const RSAKeyMeta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSAKeyMeta* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RSAKeyMeta";
  }
  protected:
  explicit RSAKeyMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tss_5frsa_2eproto);
    return ::descriptor_table_tss_5frsa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVkiArrFieldNumber = 5,
    kVkvFieldNumber = 3,
    kVkuFieldNumber = 4,
    kKFieldNumber = 1,
    kLFieldNumber = 2,
  };
  // repeated string vki_arr = 5;
  int vki_arr_size() const;
  private:
  int _internal_vki_arr_size() const;
  public:
  void clear_vki_arr();
  const std::string& vki_arr(int index) const;
  std::string* mutable_vki_arr(int index);
  void set_vki_arr(int index, const std::string& value);
  void set_vki_arr(int index, std::string&& value);
  void set_vki_arr(int index, const char* value);
  void set_vki_arr(int index, const char* value, size_t size);
  std::string* add_vki_arr();
  void add_vki_arr(const std::string& value);
  void add_vki_arr(std::string&& value);
  void add_vki_arr(const char* value);
  void add_vki_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vki_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vki_arr();
  private:
  const std::string& _internal_vki_arr(int index) const;
  std::string* _internal_add_vki_arr();
  public:

  // string vkv = 3;
  void clear_vkv();
  const std::string& vkv() const;
  void set_vkv(const std::string& value);
  void set_vkv(std::string&& value);
  void set_vkv(const char* value);
  void set_vkv(const char* value, size_t size);
  std::string* mutable_vkv();
  std::string* release_vkv();
  void set_allocated_vkv(std::string* vkv);
  private:
  const std::string& _internal_vkv() const;
  void _internal_set_vkv(const std::string& value);
  std::string* _internal_mutable_vkv();
  public:

  // string vku = 4;
  void clear_vku();
  const std::string& vku() const;
  void set_vku(const std::string& value);
  void set_vku(std::string&& value);
  void set_vku(const char* value);
  void set_vku(const char* value, size_t size);
  std::string* mutable_vku();
  std::string* release_vku();
  void set_allocated_vku(std::string* vku);
  private:
  const std::string& _internal_vku() const;
  void _internal_set_vku(const std::string& value);
  std::string* _internal_mutable_vku();
  public:

  // int32 k = 1;
  void clear_k();
  ::PROTOBUF_NAMESPACE_ID::int32 k() const;
  void set_k(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_k() const;
  void _internal_set_k(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 l = 2;
  void clear_l();
  ::PROTOBUF_NAMESPACE_ID::int32 l() const;
  void set_l(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_l() const;
  void _internal_set_l(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSAKeyMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vki_arr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vkv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vku_;
  ::PROTOBUF_NAMESPACE_ID::int32 k_;
  ::PROTOBUF_NAMESPACE_ID::int32 l_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSASigShare PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSASigShare) */ {
 public:
  inline RSASigShare() : RSASigShare(nullptr) {}
  virtual ~RSASigShare();

  RSASigShare(const RSASigShare& from);
  RSASigShare(RSASigShare&& from) noexcept
    : RSASigShare() {
    *this = ::std::move(from);
  }

  inline RSASigShare& operator=(const RSASigShare& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSASigShare& operator=(RSASigShare&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RSASigShare& default_instance();

  static inline const RSASigShare* internal_default_instance() {
    return reinterpret_cast<const RSASigShare*>(
               &_RSASigShare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RSASigShare& a, RSASigShare& b) {
    a.Swap(&b);
  }
  inline void Swap(RSASigShare* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSASigShare* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RSASigShare* New() const final {
    return CreateMaybeMessage<RSASigShare>(nullptr);
  }

  RSASigShare* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RSASigShare>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RSASigShare& from);
  void MergeFrom(const RSASigShare& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSASigShare* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RSASigShare";
  }
  protected:
  explicit RSASigShare(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tss_5frsa_2eproto);
    return ::descriptor_table_tss_5frsa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigShareFieldNumber = 2,
    kZFieldNumber = 3,
    kCFieldNumber = 4,
    kIndexFieldNumber = 1,
  };
  // string sig_share = 2;
  void clear_sig_share();
  const std::string& sig_share() const;
  void set_sig_share(const std::string& value);
  void set_sig_share(std::string&& value);
  void set_sig_share(const char* value);
  void set_sig_share(const char* value, size_t size);
  std::string* mutable_sig_share();
  std::string* release_sig_share();
  void set_allocated_sig_share(std::string* sig_share);
  private:
  const std::string& _internal_sig_share() const;
  void _internal_set_sig_share(const std::string& value);
  std::string* _internal_mutable_sig_share();
  public:

  // string z = 3;
  void clear_z();
  const std::string& z() const;
  void set_z(const std::string& value);
  void set_z(std::string&& value);
  void set_z(const char* value);
  void set_z(const char* value, size_t size);
  std::string* mutable_z();
  std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string c = 4;
  void clear_c();
  const std::string& c() const;
  void set_c(const std::string& value);
  void set_c(std::string&& value);
  void set_c(const char* value);
  void set_c(const char* value, size_t size);
  std::string* mutable_c();
  std::string* release_c();
  void set_allocated_c(std::string* c);
  private:
  const std::string& _internal_c() const;
  void _internal_set_c(const std::string& value);
  std::string* _internal_mutable_c();
  public:

  // int32 index = 1;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSASigShare)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_share_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr c_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSASigShareProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSASigShareProof) */ {
 public:
  inline RSASigShareProof() : RSASigShareProof(nullptr) {}
  virtual ~RSASigShareProof();

  RSASigShareProof(const RSASigShareProof& from);
  RSASigShareProof(RSASigShareProof&& from) noexcept
    : RSASigShareProof() {
    *this = ::std::move(from);
  }

  inline RSASigShareProof& operator=(const RSASigShareProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSASigShareProof& operator=(RSASigShareProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RSASigShareProof& default_instance();

  static inline const RSASigShareProof* internal_default_instance() {
    return reinterpret_cast<const RSASigShareProof*>(
               &_RSASigShareProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RSASigShareProof& a, RSASigShareProof& b) {
    a.Swap(&b);
  }
  inline void Swap(RSASigShareProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSASigShareProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RSASigShareProof* New() const final {
    return CreateMaybeMessage<RSASigShareProof>(nullptr);
  }

  RSASigShareProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RSASigShareProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RSASigShareProof& from);
  void MergeFrom(const RSASigShareProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSASigShareProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RSASigShareProof";
  }
  protected:
  explicit RSASigShareProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tss_5frsa_2eproto);
    return ::descriptor_table_tss_5frsa_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZFieldNumber = 1,
    kCFieldNumber = 2,
  };
  // string z = 1;
  void clear_z();
  const std::string& z() const;
  void set_z(const std::string& value);
  void set_z(std::string&& value);
  void set_z(const char* value);
  void set_z(const char* value, size_t size);
  std::string* mutable_z();
  std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string c = 2;
  void clear_c();
  const std::string& c() const;
  void set_c(const std::string& value);
  void set_c(std::string&& value);
  void set_c(const char* value);
  void set_c(const char* value, size_t size);
  std::string* mutable_c();
  std::string* release_c();
  void set_allocated_c(std::string* c);
  private:
  const std::string& _internal_c() const;
  void _internal_set_c(const std::string& value);
  std::string* _internal_mutable_c();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSASigShareProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr c_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RSAPublicKey

// string n = 1;
inline void RSAPublicKey::clear_n() {
  n_.ClearToEmpty();
}
inline const std::string& RSAPublicKey::n() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPublicKey.n)
  return _internal_n();
}
inline void RSAPublicKey::set_n(const std::string& value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPublicKey.n)
}
inline std::string* RSAPublicKey::mutable_n() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAPublicKey.n)
  return _internal_mutable_n();
}
inline const std::string& RSAPublicKey::_internal_n() const {
  return n_.Get();
}
inline void RSAPublicKey::_internal_set_n(const std::string& value) {
  
  n_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RSAPublicKey::set_n(std::string&& value) {
  
  n_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSAPublicKey.n)
}
inline void RSAPublicKey::set_n(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  n_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAPublicKey.n)
}
inline void RSAPublicKey::set_n(const char* value,
    size_t size) {
  
  n_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAPublicKey.n)
}
inline std::string* RSAPublicKey::_internal_mutable_n() {
  
  return n_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RSAPublicKey::release_n() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAPublicKey.n)
  return n_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RSAPublicKey::set_allocated_n(std::string* n) {
  if (n != nullptr) {
    
  } else {
    
  }
  n_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), n,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAPublicKey.n)
}

// string e = 2;
inline void RSAPublicKey::clear_e() {
  e_.ClearToEmpty();
}
inline const std::string& RSAPublicKey::e() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPublicKey.e)
  return _internal_e();
}
inline void RSAPublicKey::set_e(const std::string& value) {
  _internal_set_e(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPublicKey.e)
}
inline std::string* RSAPublicKey::mutable_e() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAPublicKey.e)
  return _internal_mutable_e();
}
inline const std::string& RSAPublicKey::_internal_e() const {
  return e_.Get();
}
inline void RSAPublicKey::_internal_set_e(const std::string& value) {
  
  e_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RSAPublicKey::set_e(std::string&& value) {
  
  e_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSAPublicKey.e)
}
inline void RSAPublicKey::set_e(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  e_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAPublicKey.e)
}
inline void RSAPublicKey::set_e(const char* value,
    size_t size) {
  
  e_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAPublicKey.e)
}
inline std::string* RSAPublicKey::_internal_mutable_e() {
  
  return e_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RSAPublicKey::release_e() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAPublicKey.e)
  return e_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RSAPublicKey::set_allocated_e(std::string* e) {
  if (e != nullptr) {
    
  } else {
    
  }
  e_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), e,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAPublicKey.e)
}

// -------------------------------------------------------------------

// RSAPrivateKeyShare

// int32 i = 1;
inline void RSAPrivateKeyShare::clear_i() {
  i_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RSAPrivateKeyShare::_internal_i() const {
  return i_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RSAPrivateKeyShare::i() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPrivateKeyShare.i)
  return _internal_i();
}
inline void RSAPrivateKeyShare::_internal_set_i(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  i_ = value;
}
inline void RSAPrivateKeyShare::set_i(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPrivateKeyShare.i)
}

// string si = 2;
inline void RSAPrivateKeyShare::clear_si() {
  si_.ClearToEmpty();
}
inline const std::string& RSAPrivateKeyShare::si() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPrivateKeyShare.si)
  return _internal_si();
}
inline void RSAPrivateKeyShare::set_si(const std::string& value) {
  _internal_set_si(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPrivateKeyShare.si)
}
inline std::string* RSAPrivateKeyShare::mutable_si() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAPrivateKeyShare.si)
  return _internal_mutable_si();
}
inline const std::string& RSAPrivateKeyShare::_internal_si() const {
  return si_.Get();
}
inline void RSAPrivateKeyShare::_internal_set_si(const std::string& value) {
  
  si_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RSAPrivateKeyShare::set_si(std::string&& value) {
  
  si_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSAPrivateKeyShare.si)
}
inline void RSAPrivateKeyShare::set_si(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  si_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAPrivateKeyShare.si)
}
inline void RSAPrivateKeyShare::set_si(const char* value,
    size_t size) {
  
  si_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAPrivateKeyShare.si)
}
inline std::string* RSAPrivateKeyShare::_internal_mutable_si() {
  
  return si_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RSAPrivateKeyShare::release_si() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAPrivateKeyShare.si)
  return si_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RSAPrivateKeyShare::set_allocated_si(std::string* si) {
  if (si != nullptr) {
    
  } else {
    
  }
  si_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), si,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAPrivateKeyShare.si)
}

// -------------------------------------------------------------------

// RSAKeyMeta

// int32 k = 1;
inline void RSAKeyMeta::clear_k() {
  k_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RSAKeyMeta::_internal_k() const {
  return k_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RSAKeyMeta::k() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.k)
  return _internal_k();
}
inline void RSAKeyMeta::_internal_set_k(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  k_ = value;
}
inline void RSAKeyMeta::set_k(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_k(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.k)
}

// int32 l = 2;
inline void RSAKeyMeta::clear_l() {
  l_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RSAKeyMeta::_internal_l() const {
  return l_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RSAKeyMeta::l() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.l)
  return _internal_l();
}
inline void RSAKeyMeta::_internal_set_l(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  l_ = value;
}
inline void RSAKeyMeta::set_l(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_l(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.l)
}

// string vkv = 3;
inline void RSAKeyMeta::clear_vkv() {
  vkv_.ClearToEmpty();
}
inline const std::string& RSAKeyMeta::vkv() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.vkv)
  return _internal_vkv();
}
inline void RSAKeyMeta::set_vkv(const std::string& value) {
  _internal_set_vkv(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vkv)
}
inline std::string* RSAKeyMeta::mutable_vkv() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAKeyMeta.vkv)
  return _internal_mutable_vkv();
}
inline const std::string& RSAKeyMeta::_internal_vkv() const {
  return vkv_.Get();
}
inline void RSAKeyMeta::_internal_set_vkv(const std::string& value) {
  
  vkv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RSAKeyMeta::set_vkv(std::string&& value) {
  
  vkv_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSAKeyMeta.vkv)
}
inline void RSAKeyMeta::set_vkv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vkv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAKeyMeta.vkv)
}
inline void RSAKeyMeta::set_vkv(const char* value,
    size_t size) {
  
  vkv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAKeyMeta.vkv)
}
inline std::string* RSAKeyMeta::_internal_mutable_vkv() {
  
  return vkv_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RSAKeyMeta::release_vkv() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAKeyMeta.vkv)
  return vkv_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RSAKeyMeta::set_allocated_vkv(std::string* vkv) {
  if (vkv != nullptr) {
    
  } else {
    
  }
  vkv_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vkv,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAKeyMeta.vkv)
}

// string vku = 4;
inline void RSAKeyMeta::clear_vku() {
  vku_.ClearToEmpty();
}
inline const std::string& RSAKeyMeta::vku() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.vku)
  return _internal_vku();
}
inline void RSAKeyMeta::set_vku(const std::string& value) {
  _internal_set_vku(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vku)
}
inline std::string* RSAKeyMeta::mutable_vku() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAKeyMeta.vku)
  return _internal_mutable_vku();
}
inline const std::string& RSAKeyMeta::_internal_vku() const {
  return vku_.Get();
}
inline void RSAKeyMeta::_internal_set_vku(const std::string& value) {
  
  vku_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RSAKeyMeta::set_vku(std::string&& value) {
  
  vku_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSAKeyMeta.vku)
}
inline void RSAKeyMeta::set_vku(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vku_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAKeyMeta.vku)
}
inline void RSAKeyMeta::set_vku(const char* value,
    size_t size) {
  
  vku_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAKeyMeta.vku)
}
inline std::string* RSAKeyMeta::_internal_mutable_vku() {
  
  return vku_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RSAKeyMeta::release_vku() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAKeyMeta.vku)
  return vku_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RSAKeyMeta::set_allocated_vku(std::string* vku) {
  if (vku != nullptr) {
    
  } else {
    
  }
  vku_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vku,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAKeyMeta.vku)
}

// repeated string vki_arr = 5;
inline int RSAKeyMeta::_internal_vki_arr_size() const {
  return vki_arr_.size();
}
inline int RSAKeyMeta::vki_arr_size() const {
  return _internal_vki_arr_size();
}
inline void RSAKeyMeta::clear_vki_arr() {
  vki_arr_.Clear();
}
inline std::string* RSAKeyMeta::add_vki_arr() {
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.RSAKeyMeta.vki_arr)
  return _internal_add_vki_arr();
}
inline const std::string& RSAKeyMeta::_internal_vki_arr(int index) const {
  return vki_arr_.Get(index);
}
inline const std::string& RSAKeyMeta::vki_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.vki_arr)
  return _internal_vki_arr(index);
}
inline std::string* RSAKeyMeta::mutable_vki_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAKeyMeta.vki_arr)
  return vki_arr_.Mutable(index);
}
inline void RSAKeyMeta::set_vki_arr(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vki_arr)
  vki_arr_.Mutable(index)->assign(value);
}
inline void RSAKeyMeta::set_vki_arr(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vki_arr)
  vki_arr_.Mutable(index)->assign(std::move(value));
}
inline void RSAKeyMeta::set_vki_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vki_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::set_vki_arr(int index, const char* value, size_t size) {
  vki_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline std::string* RSAKeyMeta::_internal_add_vki_arr() {
  return vki_arr_.Add();
}
inline void RSAKeyMeta::add_vki_arr(const std::string& value) {
  vki_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::add_vki_arr(std::string&& value) {
  vki_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::add_vki_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vki_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::add_vki_arr(const char* value, size_t size) {
  vki_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RSAKeyMeta::vki_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.RSAKeyMeta.vki_arr)
  return vki_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RSAKeyMeta::mutable_vki_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.RSAKeyMeta.vki_arr)
  return &vki_arr_;
}

// -------------------------------------------------------------------

// RSASigShare

// int32 index = 1;
inline void RSASigShare::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RSASigShare::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RSASigShare::index() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.index)
  return _internal_index();
}
inline void RSASigShare::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
}
inline void RSASigShare::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.index)
}

// string sig_share = 2;
inline void RSASigShare::clear_sig_share() {
  sig_share_.ClearToEmpty();
}
inline const std::string& RSASigShare::sig_share() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.sig_share)
  return _internal_sig_share();
}
inline void RSASigShare::set_sig_share(const std::string& value) {
  _internal_set_sig_share(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.sig_share)
}
inline std::string* RSASigShare::mutable_sig_share() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShare.sig_share)
  return _internal_mutable_sig_share();
}
inline const std::string& RSASigShare::_internal_sig_share() const {
  return sig_share_.Get();
}
inline void RSASigShare::_internal_set_sig_share(const std::string& value) {
  
  sig_share_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RSASigShare::set_sig_share(std::string&& value) {
  
  sig_share_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSASigShare.sig_share)
}
inline void RSASigShare::set_sig_share(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sig_share_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSASigShare.sig_share)
}
inline void RSASigShare::set_sig_share(const char* value,
    size_t size) {
  
  sig_share_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSASigShare.sig_share)
}
inline std::string* RSASigShare::_internal_mutable_sig_share() {
  
  return sig_share_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RSASigShare::release_sig_share() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShare.sig_share)
  return sig_share_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RSASigShare::set_allocated_sig_share(std::string* sig_share) {
  if (sig_share != nullptr) {
    
  } else {
    
  }
  sig_share_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sig_share,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShare.sig_share)
}

// string z = 3;
inline void RSASigShare::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& RSASigShare::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.z)
  return _internal_z();
}
inline void RSASigShare::set_z(const std::string& value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.z)
}
inline std::string* RSASigShare::mutable_z() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShare.z)
  return _internal_mutable_z();
}
inline const std::string& RSASigShare::_internal_z() const {
  return z_.Get();
}
inline void RSASigShare::_internal_set_z(const std::string& value) {
  
  z_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RSASigShare::set_z(std::string&& value) {
  
  z_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSASigShare.z)
}
inline void RSASigShare::set_z(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  z_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSASigShare.z)
}
inline void RSASigShare::set_z(const char* value,
    size_t size) {
  
  z_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSASigShare.z)
}
inline std::string* RSASigShare::_internal_mutable_z() {
  
  return z_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RSASigShare::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShare.z)
  return z_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RSASigShare::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), z,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShare.z)
}

// string c = 4;
inline void RSASigShare::clear_c() {
  c_.ClearToEmpty();
}
inline const std::string& RSASigShare::c() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.c)
  return _internal_c();
}
inline void RSASigShare::set_c(const std::string& value) {
  _internal_set_c(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.c)
}
inline std::string* RSASigShare::mutable_c() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShare.c)
  return _internal_mutable_c();
}
inline const std::string& RSASigShare::_internal_c() const {
  return c_.Get();
}
inline void RSASigShare::_internal_set_c(const std::string& value) {
  
  c_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RSASigShare::set_c(std::string&& value) {
  
  c_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSASigShare.c)
}
inline void RSASigShare::set_c(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  c_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSASigShare.c)
}
inline void RSASigShare::set_c(const char* value,
    size_t size) {
  
  c_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSASigShare.c)
}
inline std::string* RSASigShare::_internal_mutable_c() {
  
  return c_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RSASigShare::release_c() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShare.c)
  return c_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RSASigShare::set_allocated_c(std::string* c) {
  if (c != nullptr) {
    
  } else {
    
  }
  c_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), c,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShare.c)
}

// -------------------------------------------------------------------

// RSASigShareProof

// string z = 1;
inline void RSASigShareProof::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& RSASigShareProof::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShareProof.z)
  return _internal_z();
}
inline void RSASigShareProof::set_z(const std::string& value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShareProof.z)
}
inline std::string* RSASigShareProof::mutable_z() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShareProof.z)
  return _internal_mutable_z();
}
inline const std::string& RSASigShareProof::_internal_z() const {
  return z_.Get();
}
inline void RSASigShareProof::_internal_set_z(const std::string& value) {
  
  z_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RSASigShareProof::set_z(std::string&& value) {
  
  z_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSASigShareProof.z)
}
inline void RSASigShareProof::set_z(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  z_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSASigShareProof.z)
}
inline void RSASigShareProof::set_z(const char* value,
    size_t size) {
  
  z_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSASigShareProof.z)
}
inline std::string* RSASigShareProof::_internal_mutable_z() {
  
  return z_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RSASigShareProof::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShareProof.z)
  return z_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RSASigShareProof::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), z,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShareProof.z)
}

// string c = 2;
inline void RSASigShareProof::clear_c() {
  c_.ClearToEmpty();
}
inline const std::string& RSASigShareProof::c() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShareProof.c)
  return _internal_c();
}
inline void RSASigShareProof::set_c(const std::string& value) {
  _internal_set_c(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShareProof.c)
}
inline std::string* RSASigShareProof::mutable_c() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShareProof.c)
  return _internal_mutable_c();
}
inline const std::string& RSASigShareProof::_internal_c() const {
  return c_.Get();
}
inline void RSASigShareProof::_internal_set_c(const std::string& value) {
  
  c_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RSASigShareProof::set_c(std::string&& value) {
  
  c_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSASigShareProof.c)
}
inline void RSASigShareProof::set_c(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  c_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSASigShareProof.c)
}
inline void RSASigShareProof::set_c(const char* value,
    size_t size) {
  
  c_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSASigShareProof.c)
}
inline std::string* RSASigShareProof::_internal_mutable_c() {
  
  return c_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RSASigShareProof::release_c() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShareProof.c)
  return c_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RSASigShareProof::set_allocated_c(std::string* c) {
  if (c != nullptr) {
    
  } else {
    
  }
  c_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), c,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShareProof.c)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace safeheron

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tss_5frsa_2eproto
